#!/usr/bin/env bash

# Get the directory where the script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Parse command-line arguments
BUILD_DIR="${1:-${PROJECT_ROOT}/build}"

# Function to recursively list all files in the given directory with the specified extensions
list_files() {
  local dir=$1
  shift
  local extensions=("$@")
  # shellcheck disable=SC2046
  find "$dir" -type f \( -name "${extensions[0]}" $(printf -- ' -o -name "%s"' "${extensions[@]:1}") \) | sed "s|^$PROJECT_ROOT/||"
}

# Generate sources.cmake file with listed headers and sources
generate_cmake_file() {
  local headers=("${!1}")
  local sources=("${!2}")

  cat >"${BUILD_DIR}/sources.cmake" <<EOL
# Automatically generated by generate_sources.sh
set(PROJECT_HEADERS
$(for header in "${headers[@]}"; do echo "    \${CMAKE_SOURCE_DIR}/$header"; done)
)

set(PROJECT_SOURCES
$(for source in "${sources[@]}"; do echo "    \${CMAKE_SOURCE_DIR}/$source"; done)
)
EOL
}

# Define file extensions
header_extensions=("*.hpp" "*.h")
source_extensions=("*.cpp" "*.c")

# List header and source files
mapfile -t headers < <(list_files "${PROJECT_ROOT}/include" "${header_extensions[@]}")
mapfile -t sources < <(list_files "${PROJECT_ROOT}/src" "${source_extensions[@]}")

# Create the build directory if it doesn't exist
mkdir -p "${BUILD_DIR}"

# Generate the CMake file
generate_cmake_file headers[@] sources[@]

echo "sources.cmake generated successfully in ${BUILD_DIR}."
